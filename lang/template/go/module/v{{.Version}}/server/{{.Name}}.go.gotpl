package server
{{$pkgName := .Name}}
import (
	"context"
	"fmt"
	"{{.Name}}/v1"
	"sync"
)

type {{pascal .Name}}Server struct {
	mu     sync.Mutex
	{{- range .Types}}
	{{- if .Query}}
    {{pluralize (lower .Name)}} []*{{$pkgName}}.{{pascal .Name}}
    {{- end}}
    {{- end}}
	{{.Name}}.Unimplemented{{pascal .Name}}Server
}

{{translateFuncs .}}

{{- range .Types}}

{{- if .Query}}


func (h *{{pascal $pkgName}}Server) {{.Name}}(_ context.Context, req *{{$pkgName}}.Get{{.Name}}Input) (
*{{$pkgName}}.{{.Name}}, error) {
    h.mu.Lock()
    defer h.mu.Unlock()
    for _, c := range h.{{pluralize (lower .Name)}} {
        if c.Id == req.Id {
            return c, nil
        }
    }
    return nil, fmt.Errorf("{{pascal .Name}} %d not found", req.Id)
}

{{- if ne .Plural ""}}
func (h *{{pascal $pkgName}}Server) {{.Plural}}(_ context.Context, _ *{{$pkgName}}.Empty) (
	*{{$pkgName}}.{{.Plural}}, error) {
	h.mu.Lock()
	defer h.mu.Unlock()
	if h.{{pluralize (lower .Name)}} == nil {
		h.{{pluralize (lower .Name)}} = make([]*{{$pkgName}}.{{pascal .Name}}, 0)
	}
	return &{{$pkgName}}.{{pluralize (pascal .Name)}}{
	    {{pluralize (pascal .Name)}}: h.{{pluralize (lower .Name)}},
    }, nil
}

{{- end}}

{{- end}}
{{- if .Mutate}}

func (h *{{pascal $pkgName}}Server) Create{{.Name}}(_ context.Context, req *{{$pkgName}}.{{pascal .Name}}Input) (
    *{{$pkgName}}.{{pascal .Name}}, error) {
    h.mu.Lock()
    defer h.mu.Unlock()
    if h.{{pluralize (lower .Name)}} == nil {
        h.{{pluralize (lower .Name)}} = make([]*{{$pkgName}}.{{pascal .Name}}, 0)
    }
    c := New{{.Name}}(req)
    h.{{pluralize (lower .Name)}} = append(h.{{pluralize (lower .Name)}}, c)
    return c, nil
}

func (h *{{pascal $pkgName}}Server) Update{{.Name}}(_ context.Context, req *{{$pkgName}}.{{pascal .Name}}Input) (
    *{{$pkgName}}.{{pascal .Name}}, error) {
    h.mu.Lock()
    defer h.mu.Unlock()
    for _, item := range h.{{pluralize (lower .Name)}} {
        if item.Id == req.Id {
            item = New{{.Name}}(req)
            return item, nil
        }
    }
	return nil, fmt.Errorf("{{lower .Name}} %s not found", req.Id)
}

func (h *{{pascal $pkgName}}Server) Delete{{.Name}}(_ context.Context, req *{{$pkgName}}.Get{{pascal .Name}}Input) (
    *{{$pkgName}}.{{pascal .Name}}, error) {
    h.mu.Lock()
    defer h.mu.Unlock()
    if h.{{pluralize (lower .Name)}} == nil {
        h.{{pluralize (lower .Name)}} = make([]*{{$pkgName}}.{{pascal .Name}}, 0)
    }
    c := &{{$pkgName}}.{{pascal .Name}}{
        Id: req.Id,
    }
    h.{{pluralize (lower .Name)}} = append(h.{{pluralize (lower .Name)}}, c)
    return c, nil
}

{{- end}}

{{- if .Subscribe}}

func (h *{{pascal $pkgName}}Server) Stream{{.Name}}(_ *{{$pkgName}}.Empty, stream {{$pkgName}}.{{pascal .Name}}_Subscribe{{.Name}}Server) error {
    h.mu.Lock()
    defer h.mu.Unlock()
    if h.{{pluralize (lower .Name)}} == nil {
        h.{{pluralize (lower .Name)}} = make([]*{{$pkgName}}.{{pascal .Name}}, 0)
    }
    for _, c := range h.{{pluralize (lower .Name)}} {
        if err := stream.Send(c); err != nil {
            return err
        }
    }
    return nil
}

{{- end}}

{{- end}}

{{- range .Funcs}}
func (h *{{pascal $pkgName}}Server) {{.Name}}(_ context.Context, req *{{$pkgName}}.{{.Name}}Input) (
	*{{$pkgName}}.{{.Name}}Payload, error) {
	h.mu.Lock()
	defer h.mu.Unlock()

	return nil, errors.New("not implemented")
}
{{end}}

func Service() {{.Name}}.{{pascal .Name}}Server {
	return &{{pascal .Name}}Server{
		{{- range .Types}}
    	{{- if .Query}}
        {{pluralize (lower .Name)}}: make([]*{{$pkgName}}.{{pascal .Name}}, 0),
        {{- end}}
        {{- end}}
	}
}
