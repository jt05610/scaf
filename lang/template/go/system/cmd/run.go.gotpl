// Code generated by github.com/jt05610/scaf, DO NOT EDIT.
// Author: {{.Author}}
// Date: {{.Date}}
{{$sysName := .Name}}
package cmd

import (
	"fmt"
	"github.com/99designs/gqlgen/graphql/playground"
	"github.com/spf13/cobra"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
    "sync"
    "strings"
	"time"
)

func modCmds(cmd string, notify chan os.Signal, msgFmt string, mods ...string) {
	cmdSplit := strings.Split(cmd, " ")
	prg := cmdSplit[0]
	if len(mods) > 0 {
		var wg sync.WaitGroup
		for _, mod := range mods {
			wg.Add(1)
			go func(mod string) {
				defer wg.Done()
				cmd := exec.Command(prg, cmdSplit[1:]...)
				cmd.Stdout = os.Stdout
				cmd.Stderr = os.Stderr
				cmd.Dir = mod
				cmd.Start()
				go func() {
					if <-notify == os.Interrupt {
						_ = cmd.Process.Kill()
					}
				}()
				log.Printf(msgFmt, mod)
				err := cmd.Wait()
				if err != nil {
					log.Fatal(cmd.Err)
				}
			}(mod)
		}
		wg.Wait()
	} else {
		cmd := exec.Command(prg, cmdSplit[1:]...)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		err := cmd.Run()
		if err != nil {
			log.Fatal(err)
		}
	}
}

func runServer() {
    tmpDir := os.TempDir()
    certFile, err := os.Create(tmpDir + "{{.Name}}.bot+3.pem")
    if err != nil {
        log.Fatal(err)
    }
    defer os.Remove(certFile.Name())
    keyFile, err := os.Create(tmpDir + "{{.Name}}.bot+3-key.pem")
    if err != nil {
        log.Fatal(err)
    }
    defer os.Remove(keyFile.Name())

    cert, err := secrets.Open(".secrets/{{.Name}}.bot+3.pem")
    if err != nil {
        log.Fatal(err)
    }
    io.Copy(certFile, cert)
    cert.Close()
    if err != nil {
        log.Fatal(err)
    }
    key, err := secrets.Open(".secrets/{{.Name}}.bot+3-key.pem")
    if err != nil {
        log.Fatal(err)
    }
    defer key.Close()
    io.Copy(keyFile, key)
    mux := http.NewServeMux()

    mux.Handle("/", playground.Handler("GraphQL playground", "/query"))

    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt)

    s := &http.Server{
        Addr:        ":{{.PortMap.RPC}}",
        Handler:     mux,
        IdleTimeout: time.Duration(60) * time.Second,
        ReadTimeout: time.Duration(30) * time.Second,
    }
    go func() {
        for {
            if <-c == os.Interrupt {
                _ = s.Close()
            }
        }
    }()

    var wg sync.WaitGroup
    	mods := []string{
    		"data",
    		"identity",
    		"creator",
    	}
    	modCmds("go build", c, "👷‍♀️👷👷‍♂️building %s", mods...)
    	for _, f := range []struct {
    		cmd    string
    		notify chan os.Signal
    		msgFmt string
    		mods   []string
    	}{
    		{
    			cmd:    "go run main.go",
    			notify: c,
    			msgFmt: "🏃‍♀️🏃🏃‍♂️running %s",
    			mods:   mods,
    		},
    		{
    			cmd:    "pnpm serve",
    			notify: c,
    			msgFmt: "🏃‍♀️🏃🏃‍♂️running %s",
    			mods:   []string{},
    		},
    	}{
    		wg.Add(1)
    		go func() {
    			defer wg.Done()
    			modCmds(f.cmd, f.notify, f.msgFmt, f.mods...)
    		}()
    	}

	wg.Add(1)
	go func() {
		defer wg.Done()
		fmt.Println("🤖 core listening on https://{{$sysName}}.bot")
		err = s.ListenAndServeTLS(certFile.Name(), keyFile.Name())
		if err != nil && err != http.ErrServerClosed {
			log.Fatal(err)
		}
	}()
    wg.Wait()

}

// relayCmd represents the serve command
var runCmd = &cobra.Command{
	Use:   "run",
	Short: "Runs the system",
	Long: ``,
	Run: func(cmd *cobra.Command, args []string) {
        runServer()
    },

}

func init() {
	rootCmd.AddCommand(runCmd)
}
